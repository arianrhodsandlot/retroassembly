/* This file is generated by AI. */
import clsx from 'clsx'
import { random, randomInt } from 'es-toolkit'
import { useEffect, useState } from 'react'

const icons = [
  'icon-[fluent--tetris-app-24-regular]',
  'icon-[game-icons--mushroom]',
  'icon-[game-icons--ninja-star]',
  'icon-[game-icons--star-medal]',
  'icon-[game-icons--tv]',
  'icon-[iconoir--pacman]',
  'icon-[iconoir--trophy]',
  'icon-[mdi--apple-safari]',
  'icon-[mdi--campfire]',
  'icon-[mdi--candelabra-fire]',
  'icon-[mdi--chip]',
  'icon-[mdi--dice]',
  'icon-[mdi--gamepad-square]',
  'icon-[mdi--ghost]',
  'icon-[mdi--google-chrome]',
  'icon-[mdi--gun]',
  'icon-[mdi--heart]',
  'icon-[mdi--magic]',
  'icon-[mdi--nintendo-game-boy]',
  'icon-[mdi--space-invaders]',
  'icon-[mdi--star]',
  'icon-[mdi--sword]',
  'icon-[mdi--zelda]',
  'icon-[teenyicons--gba-outline]',
]

function generateIconPositions() {
  // Icon size and spacing configuration
  const iconSizePixels = 20 // Based on the size-20 class

  // We'll use a more conservative estimate for container size
  const containerApproxSize = 800

  // Calculate icon size as percentage of container
  const iconSizePercent = (iconSizePixels / containerApproxSize) * 100

  // Base margin for top-left positioning
  const margin = iconSizePercent * 1.5

  // Additional margin for bottom-right to account for the icon's full size
  // This ensures the icon's right/bottom edge stays within bounds
  const bottomRightMargin = iconSizePercent + margin

  // Significantly increase minimum distance to prevent overlaps
  // Icons must be at least 3x their size apart from each other
  const minDistance = iconSizePercent * 3

  // Maximum attempts to place each icon
  const maxAttempts = 150

  // Array to track placed positions for collision detection
  const placedPositions = []

  // Final positions to return (with style properties)
  const finalPositions = []

  // Helper function to check if a position overlaps with existing icons
  function overlaps(x, y) {
    for (const pos of placedPositions) {
      const distance = Math.hypot(pos.x - x, pos.y - y)
      // Consider it an overlap if distance is less than minDistance
      if (distance < minDistance) {
        return true
      }
    }
    return false
  }

  // Function to try placing an icon with progressive relaxation
  function placeIcon() {
    // First attempt: strict placement with no overlaps
    for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
      // Use bottomRightMargin for right and bottom edges to keep icons fully in view
      const x = random(margin, 100 - bottomRightMargin)
      const y = random(margin, 100 - bottomRightMargin)

      if (!overlaps(x, y)) {
        return { x, y }
      }
    }

    // Second attempt: find the position with maximum distance from other icons
    let bestPosition = null
    let maxMinDistance = 0

    for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
      // Use bottomRightMargin here too
      const x = random(margin, 100 - bottomRightMargin)
      const y = random(margin, 100 - bottomRightMargin)

      // Find the minimum distance to any existing icon
      let closestDistance = Number.MAX_VALUE
      for (const pos of placedPositions) {
        const distance = Math.hypot(pos.x - x, pos.y - y)
        closestDistance = Math.min(closestDistance, distance)
      }

      // If this position is better than our previous best, store it
      if (closestDistance > maxMinDistance) {
        maxMinDistance = closestDistance
        bestPosition = { x, y }
      }
    }

    // If we found a reasonable position or there are no other icons yet
    if (bestPosition && (maxMinDistance > iconSizePercent * 1.5 || placedPositions.length === 0)) {
      return bestPosition
    }

    // Last resort: use a quadrant-based approach
    // Divide screen into quadrants and place in the least crowded one
    const quadrants = [
      { count: 0, maxX: 50, maxY: 50, minX: margin, minY: margin },
      { count: 0, maxX: 100 - bottomRightMargin, maxY: 50, minX: 50, minY: margin },
      { count: 0, maxX: 50, maxY: 100 - bottomRightMargin, minX: margin, minY: 50 },
      { count: 0, maxX: 100 - bottomRightMargin, maxY: 100 - bottomRightMargin, minX: 50, minY: 50 },
    ]

    // Count icons in each quadrant
    for (const pos of placedPositions) {
      for (const q of quadrants) {
        if (pos.x >= q.minX && pos.x <= q.maxX && pos.y >= q.minY && pos.y <= q.maxY) {
          q.count += 1
        }
      }
    }

    // Find quadrant with fewest icons
    const leastCrowdedQuadrant = quadrants.sort((a, b) => a.count - b.count)[0]

    // Place in the least crowded quadrant
    return {
      x: random(leastCrowdedQuadrant.minX, leastCrowdedQuadrant.maxX),
      y: random(leastCrowdedQuadrant.minY, leastCrowdedQuadrant.maxY),
    }
  }

  // Place each icon
  for (const icon of icons) {
    const position = placeIcon()

    // Track this position for collision detection
    placedPositions.push(position)

    // Create the style object for this icon
    finalPositions.push({
      '--motion-delay': `${randomInt(0, 500)}ms`,
      '--motion-duration': `${randomInt(2000, 2500)}ms`,
      left: `${position.x}%`,
      top: `${position.y}%`,
    })
  }

  return finalPositions
}

export function Icons() {
  // Use state to store positions and track client-side rendering
  const [iconPositions, setIconPositions] = useState([])
  const [isClient, setIsClient] = useState(false)

  // Only generate positions on the client side after initial render
  useEffect(() => {
    setIsClient(true)
    setIconPositions(generateIconPositions())
  }, [])

  return (
    <>
      {icons.map((icon, index) => (
        <span
          className={clsx(
            icon,
            'motion-delay-500 motion-preset-oscillate-sm motion-duration-2000 absolute size-20 text-neutral-200',
            // Hide icons during server-side rendering to prevent hydration mismatch
            !isClient && 'opacity-0',
          )}
          key={icon}
          style={isClient ? iconPositions[index] : { position: 'absolute' }}
        />
      ))}
    </>
  )
}
