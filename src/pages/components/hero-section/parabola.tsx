/* This file is generated by AI. */
import { random, randomInt } from 'es-toolkit'
import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { getCDNUrl } from '@/utils/cdn.ts'

// Type definitions for better code organization
interface Position {
  x: number
  y: number
}

interface Velocity {
  x: number
  y: number
}

interface ObjectConfig {
  baseSize: number
  delay: number
  iconIndex: number
  id: number
  initialPosition: Position
  initialRotation: number
  initialSize: number
  rotationSpeed: number
}

interface AnimationState {
  active: boolean
  iconIndex: number
  position: Position
  rotation: number
  rotationSpeed: number
  size: number
  velocity: Velocity
}

interface ParabolaProps {
  /** Base size for the objects in pixels */
  baseSize?: number
  /** Alternative icon URLs to use instead of default console icons */
  customIcons?: string[]
  /** Height factor affecting how high objects are thrown (higher = higher throws) */
  heightFactor?: number
  /** Number of objects to animate */
  objectCount?: number
}

// Default console icon paths
const DEFAULT_ICONS = [
  'atari2600',
  'gamegear',
  'gb',
  'gba',
  'gbc',
  'megadrive',
  'nes',
  'ngp',
  'ngpc',
  'sg1000',
  'snes',
  'virtualboy',
  'wonderswan',
  'wonderswancolor',
].map((platform) => getCDNUrl('batocera-linux/batocera-themes', `themes/batocera/${platform}/_data/svg/console.svg`))

// Animation constants with const assertions for better type safety
const DEFAULT_CONFIG = {
  BASE_SIZE: 100,
  GRAVITY_BASE: 0.0002,
  HEIGHT_FACTOR: 1.2,
  HORIZONTAL_VELOCITY_BASE: 0.0025,
  OBJECT_COUNT: 4,
  ROTATION_SPEED_RANGE: 3, // degrees per frame (±)
  SIZE_VARIATION: 0.2, // ±20% size variation
  VERTICAL_VELOCITY_BASE: 0.008,
} as const

/**
 * Custom hook for managing animation physics in the parabola component
 */
function useParabolaAnimation(
  containerRef: React.RefObject<HTMLDivElement>,
  objectConfigs: ObjectConfig[],
  heightFactor: number,
) {
  const [containerSize, setContainerSize] = useState({ height: 0, width: 0 })
  const objectsRef = useRef<(HTMLDivElement | null)[]>([])
  const animationRef = useRef<number | undefined>(undefined)
  const [isClient, setIsClient] = useState(false)
  const usedIconIndicesRef = useRef<number[]>([])

  // Update used icon indices when configs change
  useEffect(() => {
    usedIconIndicesRef.current = objectConfigs.map((config) => config.iconIndex)
  }, [objectConfigs])

  // Initialize client-side and container size
  useEffect(() => {
    setIsClient(true)

    function updateContainerSize() {
      if (!containerRef.current) {
        return
      }

      setContainerSize({
        height: containerRef.current.clientHeight,
        width: containerRef.current.clientWidth,
      })
    }

    updateContainerSize()

    // Use ResizeObserver for responsive container size updates
    const resizeObserver = new ResizeObserver(updateContainerSize)
    if (containerRef.current) {
      resizeObserver.observe(containerRef.current)
    }

    return () => {
      resizeObserver.disconnect()
    }
  }, [containerRef])

  /**
   * Reset an animation state when object goes out of bounds
   */
  const resetAnimationState = useCallback(
    // eslint-disable-next-line max-params
    (state: AnimationState, containerWidth: number, containerHeight: number, baseSize: number): void => {
      // Generate new random parameters
      const newInitialPosition = getRandomInitialPosition()
      const newInitialVelocity = getRandomInitialVelocity(newInitialPosition, heightFactor)

      // Update position
      state.position = {
        x: newInitialPosition.x * containerWidth,
        y: newInitialPosition.y * containerHeight,
      }

      // Update velocity
      state.velocity = {
        x: newInitialVelocity.x * containerWidth,
        y: newInitialVelocity.y * containerHeight,
      }

      // Remove current icon index from used list
      usedIconIndicesRef.current = usedIconIndicesRef.current.filter((idx) => idx !== state.iconIndex)

      // Choose a new unique random icon and update tracking array
      const newIconIndex = getUniqueRandomIconIndex(usedIconIndicesRef.current)
      state.iconIndex = newIconIndex
      usedIconIndicesRef.current.push(newIconIndex)

      // Generate random size
      state.size = getRandomSize(baseSize)

      // Generate new random rotation properties
      state.rotation = getRandomRotation()
      state.rotationSpeed = getRandomRotationSpeed()
    },
    [heightFactor],
  )

  // Run animation loop
  useEffect(() => {
    // Only run animation on client side with valid container dimensions
    if (!isClient || !containerRef.current || containerSize.width === 0) {
      return
    }

    const containerWidth = containerSize.width
    const containerHeight = containerSize.height

    // Initialize object states
    const objectStates: AnimationState[] = objectConfigs.map((config) => {
      const initialVelocity = getRandomInitialVelocity(config.initialPosition, heightFactor)

      return {
        active: false,
        iconIndex: config.iconIndex,
        position: {
          x: config.initialPosition.x * containerWidth,
          y: config.initialPosition.y * containerHeight,
        },
        rotation: config.initialRotation,
        rotationSpeed: config.rotationSpeed,
        size: config.initialSize,
        velocity: {
          x: initialVelocity.x * containerWidth,
          y: initialVelocity.y * containerHeight,
        },
      }
    })

    // Calculate gravity based on container height and height factor
    const gravity = calculateGravity(containerHeight, heightFactor)

    // Set timeouts for delayed starts
    const timeoutIds: NodeJS.Timeout[] = []
    for (const [index, config] of objectConfigs.entries()) {
      const timeoutId = setTimeout(() => {
        objectStates[index].active = true
      }, config.delay)
      timeoutIds.push(timeoutId)
    }

    // Animation function
    function animate() {
      for (const [index, state] of objectStates.entries()) {
        // Skip objects that aren't active yet
        if (!state.active) {
          continue
        }

        // Apply physics updates
        state.velocity.y += gravity
        state.position.x += state.velocity.x
        state.position.y += state.velocity.y
        state.rotation += state.rotationSpeed

        // Update object position and rotation in the DOM
        const objectElement = objectsRef.current[index]
        if (objectElement) {
          objectElement.style.transform = `translate(${state.position.x}px, ${state.position.y}px) rotate(${state.rotation}deg)`

          // Check if object is out of bounds
          const movingRightToLeft = state.velocity.x < 0
          const isOutOfBounds =
            state.position.y > containerHeight || // Bottom edge
            (movingRightToLeft && state.position.x < 0) || // Left edge (for right-to-left)
            (!movingRightToLeft && state.position.x > containerWidth) // Right edge (for left-to-right)

          if (isOutOfBounds) {
            resetAnimationState(state, containerWidth, containerHeight, objectConfigs[index].baseSize)
          }
        }
      }

      animationRef.current = requestAnimationFrame(animate)
    }

    // Start the animation
    animationRef.current = requestAnimationFrame(animate)

    // Clean up on unmount or when dependencies change
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current)
      }
      for (const id of timeoutIds) {
        clearTimeout(id)
      }
    }
  }, [isClient, heightFactor, containerRef, objectConfigs, containerSize, resetAnimationState])

  return {
    containerSize,
    isClient,
    objectsRef,
  }
}

/**
 * Returns a random icon index from the icons array
 * @param iconsLength - Length of the icons array
 */
function getRandomIconIndex(iconsLength: number): number {
  return randomInt(0, iconsLength - 1)
}

/**
 * Returns a unique random icon index that isn't in the excluded list
 * @param excludedIndices - Array of icon indices that are already in use
 * @param iconsLength - Length of the icons array
 */
function getUniqueRandomIconIndex(excludedIndices: number[], iconsLength: number = DEFAULT_ICONS.length): number {
  // If all icons are in use, just return a random one
  if (excludedIndices.length >= iconsLength) {
    return getRandomIconIndex(iconsLength)
  }

  // Keep trying until we get a unique icon
  let index: number
  do {
    index = getRandomIconIndex(iconsLength)
  } while (excludedIndices.includes(index))

  return index
}

/**
 * Returns a random size based on the base size
 * @param baseSize - The base size to calculate random size from
 */
function getRandomSize(baseSize: number): number {
  // Random factor between 0.8 and 1.2 (±20% of base size)
  const randomFactor = 1 - DEFAULT_CONFIG.SIZE_VARIATION + random(0, DEFAULT_CONFIG.SIZE_VARIATION * 2)
  return Math.round(baseSize * randomFactor)
}

/**
 * Returns a random initial position at the bottom of the container
 */
function getRandomInitialPosition(): Position {
  // Randomly choose between left side (0-0.15) and right side (0.85-1)
  const isLeftSide = random(0, 1) < 0.5

  return {
    // X position either on left side or right side of container
    x: isLeftSide
      ? random(0, 0.15) // Left side: 0 to 0.15
      : 0.85 + random(0, 0.15), // Right side: 0.85 to 1
    y: 1, // Always start at bottom (y = 1)
  }
}

/**
 * Returns a random initial velocity based on position and height factor
 */
function getRandomInitialVelocity(initialPosition: Position, heightFactor: number): Velocity {
  // If starting from left side, go right; if from right side, go left
  const isLeftSide = initialPosition.x < 0.5

  // Horizontal velocity with direction based on starting position
  const baseHorizontalVelocity =
    (DEFAULT_CONFIG.HORIZONTAL_VELOCITY_BASE + random(0, DEFAULT_CONFIG.HORIZONTAL_VELOCITY_BASE)) *
    (isLeftSide ? 1 : -1)

  // Vertical velocity (negative = upward) scaled by height factor
  const baseVerticalVelocity =
    -(DEFAULT_CONFIG.VERTICAL_VELOCITY_BASE + random(0, DEFAULT_CONFIG.VERTICAL_VELOCITY_BASE / 2)) * heightFactor

  return { x: baseHorizontalVelocity, y: baseVerticalVelocity }
}

/**
 * Returns a random rotation speed in degrees per frame
 */
function getRandomRotationSpeed(): number {
  // Random speed between -3 and 3 degrees per frame (or whatever ROTATION_SPEED_RANGE is set to)
  return random(-DEFAULT_CONFIG.ROTATION_SPEED_RANGE, DEFAULT_CONFIG.ROTATION_SPEED_RANGE)
}

/**
 * Returns a random initial rotation in degrees
 */
function getRandomRotation(): number {
  // Random angle between 0 and 360 degrees
  return random(0, 360)
}

/**
 * Generates configuration for animation objects with pre-calculated positions
 */
function generateObjectConfigs(count: number, baseSize: number, iconsLength: number): ObjectConfig[] {
  const usedIconIndices: number[] = []

  return Array.from({ length: count }, (_, i) => {
    const initialPosition = getRandomInitialPosition()
    const initialSize = getRandomSize(baseSize)

    // Get a unique icon index that's not already used
    const iconIndex = getUniqueRandomIconIndex(usedIconIndices, iconsLength)
    usedIconIndices.push(iconIndex)

    return {
      baseSize,
      delay: i * 700 + randomInt(0, 300), // Staggered delays with some randomness
      iconIndex,
      id: i,
      initialPosition,
      initialRotation: getRandomRotation(),
      initialSize,
      rotationSpeed: getRandomRotationSpeed(),
    }
  })
}

/**
 * Calculate gravity based on height factor and container height
 */
function calculateGravity(containerHeight: number, heightFactor: number): number {
  return (DEFAULT_CONFIG.GRAVITY_BASE / heightFactor) * containerHeight
}

/**
 * Paralolas component that animates retro console icons in parabolic arcs
 * with physics-based motion and rotation.
 */
export function Paralolas({
  baseSize = DEFAULT_CONFIG.BASE_SIZE,
  customIcons,
  heightFactor = DEFAULT_CONFIG.HEIGHT_FACTOR,
  objectCount = DEFAULT_CONFIG.OBJECT_COUNT,
}: ParabolaProps) {
  const containerRef = useRef<HTMLDivElement>(null)

  // Use either provided custom icons or the default console icons
  const icons = customIcons || DEFAULT_ICONS

  // Generate object configurations - memoized to prevent recreating on every render
  const objectConfigs = useMemo(
    () => generateObjectConfigs(objectCount, baseSize, icons.length),
    [objectCount, baseSize, icons.length],
  )

  // Custom animation hook handles the physics and animation loop
  const { containerSize, isClient, objectsRef } = useParabolaAnimation(containerRef, objectConfigs, heightFactor)

  return (
    <div className='relative size-full overflow-hidden' ref={containerRef}>
      {isClient &&
        objectConfigs.map((config, index) => {
          // Calculate initial position in pixels if container dimensions are available
          const initialX = containerSize.width ? config.initialPosition.x * containerSize.width : 0
          const initialY = containerSize.height ? config.initialPosition.y * containerSize.height : 0

          return (
            <div
              className='absolute'
              key={config.id}
              ref={(el) => {
                objectsRef.current[index] = el
              }}
              style={{
                height: `${config.initialSize}px`,
                left: 0,
                opacity: containerSize.width ? 1 : 0,
                top: 0,
                transform: containerSize.width
                  ? `translate(${initialX}px, ${initialY}px) rotate(${config.initialRotation}deg)`
                  : 'none',
                transition: 'opacity 0.3s ease-in',
                width: `${config.initialSize}px`,
              }}
            >
              <img
                alt='Console icon'
                className='size-full object-contain'
                loading='lazy'
                src={icons[config.iconIndex]}
              />
            </div>
          )
        })}
    </div>
  )
}
