/* This file is generated by AI. */
import { random, randomInt } from 'es-toolkit'
import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { getCDNUrl } from '@/utils/cdn.ts'

// Type definitions for better code organization
interface Position {
  x: number
  y: number
}

interface Velocity {
  x: number
  y: number
}

interface ObjectConfig {
  baseSize: number
  delay: number
  id: number
  initialPosition: Position
  initialRotation: number
  initialSize: number
  rotationSpeed: number
}

interface AnimationState {
  active: boolean
  iconIndex: number
  id: number
  position: Position
  rotation: number
  rotationSpeed: number
  size: number
  velocity: Velocity
}

interface ParabolaProps {
  /** Base size for the objects in pixels */
  baseSize?: number
  /** Alternative icon URLs to use instead of default console icons */
  customIcons?: string[]
  /** Height factor affecting how high objects are thrown (higher = higher throws) */
  heightFactor?: number
  /** Number of objects to animate */
  objectCount?: number
}

// Default console icon paths
const DEFAULT_ICONS = [
  'atari2600',
  'gamegear',
  'gb',
  'gba',
  'gbc',
  'megadrive',
  'nes',
  'ngp',
  'ngpc',
  'sg1000',
  'snes',
  'virtualboy',
  'wonderswan',
  'wonderswancolor',
].map((platform) => getCDNUrl('batocera-linux/batocera-themes', `themes/batocera/${platform}/_data/svg/console.svg`))

// Animation constants with const assertions for better type safety
const DEFAULT_CONFIG = {
  BASE_SIZE: 100,
  GRAVITY_BASE: 0.0002,
  HEIGHT_FACTOR: 1.3,
  HORIZONTAL_VELOCITY_BASE: 0.0025,
  OBJECT_COUNT: 3,
  ROTATION_SPEED_RANGE: 3, // degrees per frame (±)
  SIZE_VARIATION: 0.2, // ±20% size variation
  VERTICAL_VELOCITY_BASE: 0.008,
} as const

/**
 * Returns a random size based on the base size
 * @param baseSize - The base size to calculate random size from
 */
function getRandomSize(baseSize: number): number {
  // Random factor between 0.8 and 1.2 (±20% of base size)
  const randomFactor = 1 - DEFAULT_CONFIG.SIZE_VARIATION + random(0, DEFAULT_CONFIG.SIZE_VARIATION * 2)
  return Math.round(baseSize * randomFactor)
}

/**
 * Returns a random initial position at the bottom of the container
 */
function getRandomInitialPosition(): Position {
  // Randomly choose between left side (0-0.15) and right side (0.85-1)
  const isLeftSide = random(0, 1) < 0.5

  return {
    // X position either on left side or right side of container
    x: isLeftSide
      ? random(0, 0.15) // Left side: 0 to 0.15
      : 0.85 + random(0, 0.15), // Right side: 0.85 to 1
    y: 1, // Position slightly below the container (1.0 would be exactly at bottom edge)
  }
}

/**
 * Returns a random initial velocity based on position and height factor
 */
function getRandomInitialVelocity(initialPosition: Position, heightFactor: number): Velocity {
  // If starting from left side, go right; if from right side, go left
  const isLeftSide = initialPosition.x < 0.5

  // Horizontal velocity with direction based on starting position
  const baseHorizontalVelocity =
    (DEFAULT_CONFIG.HORIZONTAL_VELOCITY_BASE + random(0, DEFAULT_CONFIG.HORIZONTAL_VELOCITY_BASE)) *
    (isLeftSide ? 1 : -1)

  // Vertical velocity (negative = upward) scaled by height factor
  const baseVerticalVelocity =
    -(DEFAULT_CONFIG.VERTICAL_VELOCITY_BASE + random(0, DEFAULT_CONFIG.VERTICAL_VELOCITY_BASE / 2)) * heightFactor

  return { x: baseHorizontalVelocity, y: baseVerticalVelocity }
}

/**
 * Returns a random rotation speed in degrees per frame
 */
function getRandomRotationSpeed(): number {
  // Random speed between -3 and 3 degrees per frame (or whatever ROTATION_SPEED_RANGE is set to)
  return random(-DEFAULT_CONFIG.ROTATION_SPEED_RANGE, DEFAULT_CONFIG.ROTATION_SPEED_RANGE)
}

/**
 * Returns a random initial rotation in degrees
 */
function getRandomRotation(): number {
  // Random angle between 0 and 360 degrees
  return random(0, 360)
}

/**
 * Calculate gravity based on height factor and container height
 */
function calculateGravity(containerHeight: number, heightFactor: number): number {
  return (DEFAULT_CONFIG.GRAVITY_BASE / heightFactor) * containerHeight
}

/**
 * Returns a random icon index from the icons array
 * @param iconsLength - Length of the icons array
 */
function getRandomIconIndex(iconsLength: number): number {
  return randomInt(0, iconsLength - 1)
}

/**
 * Returns a unique random icon index that isn't in the excluded list
 * @param excludedIndices - Array of icon indices that are already in use
 * @param iconsLength - Length of the icons array
 */
function getUniqueRandomIconIndex(excludedIndices: number[], iconsLength: number = DEFAULT_ICONS.length): number {
  // If all icons are in use, just return a random one
  if (excludedIndices.length >= iconsLength) {
    return getRandomIconIndex(iconsLength)
  }

  // Keep trying until we get a unique icon
  let index: number
  do {
    index = getRandomIconIndex(iconsLength)
  } while (excludedIndices.includes(index))

  return index
}

/**
 * Generates configuration for animation objects with pre-calculated positions
 */
function generateObjectConfigs(count: number, baseSize: number): ObjectConfig[] {
  return Array.from({ length: count }, (_, i) => {
    const initialPosition = getRandomInitialPosition()
    const initialSize = getRandomSize(baseSize)

    return {
      baseSize,
      delay: i * 700 + randomInt(0, 300), // Staggered delays with some randomness
      id: i,
      initialPosition,
      initialRotation: getRandomRotation(),
      initialSize,
      rotationSpeed: getRandomRotationSpeed(),
    }
  })
}

/**
 * Custom hook for managing animation physics in the parabola component
 */
function useParabolaAnimation(
  containerRef: React.RefObject<HTMLDivElement>,
  objectConfigs: ObjectConfig[],
  heightFactor: number,
  objectCount: number,
  iconsLength: number,
) {
  const [containerSize, setContainerSize] = useState({ height: 0, width: 0 })
  const objectsRef = useRef<(HTMLDivElement | null)[]>([])
  const animationRef = useRef<number | undefined>(undefined)
  const [isClient, setIsClient] = useState(false)

  // Track active objects and their states
  const [activeObjects, setActiveObjects] = useState<AnimationState[]>([])
  const activeObjectsRef = useRef<AnimationState[]>([]) // Ref to avoid dependency cycles
  const usedIconIndicesRef = useRef<number[]>([])
  const nextIdRef = useRef<number>(objectConfigs.length)

  // Initialize client-side and container size
  useEffect(() => {
    setIsClient(true)

    function updateContainerSize() {
      if (!containerRef.current) {
        return
      }

      setContainerSize({
        height: containerRef.current.clientHeight,
        width: containerRef.current.clientWidth,
      })
    }

    updateContainerSize()

    // Use ResizeObserver for responsive container size updates
    const resizeObserver = new ResizeObserver(updateContainerSize)
    if (containerRef.current) {
      resizeObserver.observe(containerRef.current)
    }

    return () => {
      resizeObserver.disconnect()
    }
  }, [containerRef])

  /**
   * Create a new animation state with random properties
   */
  const createNewAnimationState = useCallback(
    (id: number, containerWidth: number, containerHeight: number, baseSize: number, delayMs = 0): AnimationState => {
      const initialPosition = getRandomInitialPosition()
      const initialVelocity = getRandomInitialVelocity(initialPosition, heightFactor)

      // Choose a unique icon index that's not currently in use
      const iconIndex = getUniqueRandomIconIndex(usedIconIndicesRef.current, iconsLength)
      usedIconIndicesRef.current.push(iconIndex)

      return {
        active: delayMs <= 0,
        iconIndex,
        id,
        position: {
          x: initialPosition.x * containerWidth,
          y: initialPosition.y * containerHeight,
        },
        rotation: getRandomRotation(),
        rotationSpeed: getRandomRotationSpeed(),
        size: getRandomSize(baseSize),
        velocity: {
          x: initialVelocity.x * containerWidth,
          y: initialVelocity.y * containerHeight,
        },
      }
    },
    [heightFactor, iconsLength],
  )

  // Initialize active objects
  useEffect(() => {
    if (!isClient || containerSize.width === 0 || containerSize.height === 0) {
      return
    }

    // Reset used icons
    usedIconIndicesRef.current = []
    nextIdRef.current = objectConfigs.length

    // Create initial objects with staggered delays
    const initialObjects: AnimationState[] = objectConfigs
      .slice(0, objectCount)
      .map((config) =>
        createNewAnimationState(config.id, containerSize.width, containerSize.height, config.baseSize, config.delay),
      )

    setActiveObjects(initialObjects)
    activeObjectsRef.current = initialObjects

    // Activate delayed objects after their delay time
    const timeoutIds: NodeJS.Timeout[] = initialObjects
      .filter((obj) => !obj.active)
      .map((obj) => {
        const config = objectConfigs.find((c) => c.id === obj.id)
        if (!config) {
          return
        }

        return setTimeout(() => {
          setActiveObjects((prevObjects) => {
            const updatedObjects = prevObjects.map((o) => (o.id === obj.id ? { ...o, active: true } : o))
            activeObjectsRef.current = updatedObjects
            return updatedObjects
          })
        }, config.delay)
      })
      .filter(Boolean) as NodeJS.Timeout[]

    return () => {
      for (const id of timeoutIds) {
        clearTimeout(id)
      }
    }
  }, [isClient, containerSize.width, containerSize.height, objectConfigs, createNewAnimationState, objectCount])

  // Run animation loop
  useEffect(() => {
    // Only run animation on client side with valid container dimensions
    if (!isClient || !containerRef.current || containerSize.width === 0) {
      return
    }

    const containerWidth = containerSize.width
    const containerHeight = containerSize.height

    // Calculate gravity based on container height and height factor
    const gravity = calculateGravity(containerHeight, heightFactor)

    // Animation function
    function animate() {
      // Clone current state to avoid mutating during iteration
      const currentObjects = activeObjectsRef.current
      const updatedObjects = [...currentObjects]
      let hasChanges = false

      // Process existing objects
      for (let i = updatedObjects.length - 1; i >= 0; i--) {
        const state = updatedObjects[i]

        // Skip objects that aren't active yet
        if (!state.active) {
          continue
        }

        // Apply physics updates
        state.velocity.y += gravity
        state.position.x += state.velocity.x
        state.position.y += state.velocity.y
        state.rotation += state.rotationSpeed

        // Update object position and rotation in the DOM
        const objectElement = objectsRef.current[i]
        if (objectElement) {
          objectElement.style.transform = `translate(${state.position.x}px, ${state.position.y}px) rotate(${state.rotation}deg)`
        }

        // Check if object is out of bounds
        const movingRightToLeft = state.velocity.x < 0
        const isOutOfBounds =
          state.position.y > containerHeight || // Bottom edge
          (movingRightToLeft && state.position.x < 0) || // Left edge (for right-to-left)
          (!movingRightToLeft && state.position.x > containerWidth) // Right edge (for left-to-right)

        if (isOutOfBounds) {
          // Remove icon index from used list
          usedIconIndicesRef.current = usedIconIndicesRef.current.filter((idx) => idx !== state.iconIndex)

          // Remove the object
          updatedObjects.splice(i, 1)
          hasChanges = true
        }
      }

      // Add new objects if we're below the object count
      while (updatedObjects.length < objectCount) {
        const newObject = createNewAnimationState(
          nextIdRef.current++,
          containerWidth,
          containerHeight,
          DEFAULT_CONFIG.BASE_SIZE,
        )

        updatedObjects.push(newObject)
        hasChanges = true
      }

      // Update state if objects were added or removed
      if (hasChanges) {
        activeObjectsRef.current = updatedObjects
        setActiveObjects(updatedObjects)
      }

      animationRef.current = requestAnimationFrame(animate)
    }

    // Start the animation
    animationRef.current = requestAnimationFrame(animate)

    // Clean up on unmount or when dependencies change
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current)
      }
    }
  }, [
    isClient,
    heightFactor,
    containerRef,
    containerSize.width,
    containerSize.height,
    objectCount,
    createNewAnimationState,
  ])

  return {
    activeObjects,
    containerSize,
    isClient,
    objectsRef,
  }
}

/**
 * Paralolas component that animates retro console icons in parabolic arcs
 * with physics-based motion and rotation.
 */
export function Paralolas({
  baseSize = DEFAULT_CONFIG.BASE_SIZE,
  customIcons,
  heightFactor = DEFAULT_CONFIG.HEIGHT_FACTOR,
  objectCount = DEFAULT_CONFIG.OBJECT_COUNT,
}: Readonly<ParabolaProps>) {
  const containerRef = useRef<HTMLDivElement>(null)

  // Use either provided custom icons or the default console icons
  const icons = customIcons || DEFAULT_ICONS

  // Generate object configurations - memoized to prevent recreating on every render
  const objectConfigs = useMemo(
    () => generateObjectConfigs(Math.max(objectCount * 2, 10), baseSize),
    [objectCount, baseSize],
  )

  // Custom animation hook handles the physics and animation loop
  const { activeObjects, isClient, objectsRef } = useParabolaAnimation(
    containerRef,
    objectConfigs,
    heightFactor,
    objectCount,
    icons.length,
  )

  return (
    <div className='relative size-full overflow-hidden' ref={containerRef}>
      {isClient &&
        activeObjects.map((object, index) => (
          <div
            className='absolute'
            key={object.id}
            ref={(el) => {
              objectsRef.current[index] = el
            }}
            style={{
              height: `${object.size}px`,
              left: 0,
              opacity: object.active ? 1 : 0,
              top: 0,
              transform: `translate(${object.position.x}px, ${object.position.y}px) rotate(${object.rotation}deg)`,
              transition: 'opacity 0.3s ease-in',
              width: `${object.size}px`,
            }}
          >
            <img alt='Console icon' className='size-full object-contain' loading='lazy' src={icons[object.iconIndex]} />
          </div>
        ))}
    </div>
  )
}
