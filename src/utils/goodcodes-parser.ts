/** This file is compiled from https://github.com/jbdemonte/goodcodes-parser */
/* eslint-disable */
var A = { tags: ["[a]", "[a#]", "[a#C]", "[a#+C]", "[a#+#C]", "(alt #)"], key: "alternative", title: "Alternative version", description: "The ROM is a copy of an alternative release of the game. Many games have been re-released to fix bugs or to eliminate Game Genie codes.", re: /^\[a(\d*)(?:(\+)?(\d+)?C)?]|\(alt\s*(\d+)\)$/i, cast (o) { if (o[1] || o[4]) return { major: parseInt(o[1] || o[4] || 0, 10), minor: parseInt(o[3] || 0, 10) || (o[2] ? 1 : 0) }; return !0 } }; function s (o) { return { re: new RegExp(`^\\[${o}(\\d*)(?:(\\+)?(\\d+)?C)?\\]$`, "i"), cast (i) { if (i[1]) return { major: parseInt(i[1] || 0, 10), minor: parseInt(i[3] || 0, 10) || (i[2] ? 1 : 0) }; return !0 } } } var S = { tags: ["[b]", "[b#]", "[b#C]", "[b#+C]", "[b#+#C]"], key: "bad", title: "Bad dump", description: "A ROM image which has been corrupted because the original game is very old, because of a faulty dumper (bad connection) or during its upload to a release server. These ROMs often have graphic errors or sometimes don't work at all.", ...s("b") }; var T = { tags: ["[c]", "[x]"], key: "checksum", title: "Checksum", description: "Genesis only, ROM provide a good / bad checksum.", re: /^\[(c|x)]$/, cast (o) { return o[1].toLowerCase() === "c" ? { good: !0 } : { bad: !0 } } }; var P = { tag: "(Compilation)", key: "compilation", title: "Compilation", description: "The ROM is a dump of a compilation", re: /^\(Compilation\)$/ }; var C = [{ code: "Alb", name: "Albanian" }, { code: "Ara", name: "Arabic" }, { code: "Bra", name: "Brazilian Portuguese" }, { code: "Chi", name: "Chinese" }, { code: "ChS", name: "Simplified Chinese" }, { code: "SChi", name: "Simplified Chinese" }, { code: "Ch-Simp", name: "Simplified Chinese" }, { code: "Ch-Simple", name: "Simplified Chinese" }, { code: "ChT", name: "Traditional Chinese" }, { code: "TChi", name: "Traditional Chinese" }, { code: "Ch-Trad", name: "Traditional Chinese" }, { code: "Cro", name: "Croatia" }, { code: "Dan", name: "Danish" }, { code: "Dut", name: "Dutch" }, { code: "Eng", name: "English" }, { code: "Fin", name: "Finnish" }, { code: "Fre", name: "French" }, { code: "Ger", name: "German" }, { code: "Gre", name: "Greek" }, { code: "Heb", name: "Hebrew" }, { code: "Ita", name: "Italian" }, { code: "Jap", name: "Japanese" }, { code: "Kor", name: "Korean" }, { code: "Lat", name: "Latvian" }, { code: "Lit", name: "Lithuanian" }, { code: "Nor", name: "Norwegian" }, { code: "Pol", name: "Polish" }, { code: "Por", name: "Portuguese" }, { code: "Rom", name: "Romanian" }, { code: "Rum", name: "Romanian" }, { code: "Rus", name: "Russian" }, { code: "Ser", name: "Serbian" }, { code: "Spa", name: "Spanish" }, { code: "Swe", name: "Swedish" }, { code: "Tai", name: "Thai" }, { code: "Tur", name: "Turkish" }, { code: "Uru", name: "Uruguay Spanish" }]; function p (o) { let i = C.find((r) => r.code === o); if (!i) throw new Error(`Language not found for code ${o}`); return i } var $ = [{ code: "1", name: "Japan & Korea", language: p("Jap") }, { code: "4", name: "USA & Brazil", language: p("Eng") }, { code: "A", name: "Australia", language: p("Eng") }, { code: "As", name: "Asia", language: p("Jap") }, { code: "B", name: "Brazil", language: p("Bra") }, { code: "Ch", name: "China", language: p("SChi") }, { code: "C", name: "Canada", language: p("Eng") }, { code: "D", name: "Netherlands", language: p("Dut") }, { code: "E", name: "Europe", language: p("Eng") }, { code: "F", name: "France", language: p("Fre") }, { code: "Fn", name: "Finland", language: p("Fin") }, { code: "G", name: "Germany", language: p("Dut") }, { code: "Gr", name: "Greece", language: p("Gre") }, { code: "HK", name: "Hong Kong", language: p("SChi") }, { code: "I", name: "Italy", language: p("Ita") }, { code: "J", name: "Japan", language: p("Jap") }, { code: "K", name: "Korea", language: p("Kor") }, { code: "Nl", name: "Netherlands", language: p("Dut") }, { code: "No", name: "Norway", language: p("Nor") }, { code: "R", name: "Russia", language: p("Rus") }, { code: "S", name: "Spain", language: p("Spa") }, { code: "Sw", name: "Sweden", language: p("Swe") }, { code: "U", name: "USA", language: p("Eng") }, { code: "UK", name: "United Kingdom", language: p("Eng") }, { code: "Tw", name: "Taiwan", language: p("Tai") }, { code: "W", name: "World", language: p("Eng") }, { code: "Unl", name: "Unlicensed", language: p("Eng") }, { code: "PD", name: "Public domain", language: p("Eng") }, { code: "Unk", name: "Unknown", language: p("Eng") }], b = $.map((o) => ({ code: o.code, name: o.name })); function v (o) { let i = $.find((r) => r.code === o); if (i) return i.language } function I (o) { let i = new RegExp(o.filter((r) => r.name.indexOf(" ") >= 0).map((r) => `(${r.name.toLowerCase()})`).join("|"), "g"); return (r) => r.toLowerCase().replace(i, (e) => e.replace(/\s+/, "-")) } var M = I(C), R = I(b); var x = {}; b.forEach((o) => { x[o.code.toLowerCase()] = o, x[R(o.name)] = o }); function n (o) { let i = []; return o.split(/[,\s]+/).forEach((r) => { let e = x[r.trim()]; if (e) i.push(e) }), i.length ? i : void 0 } var L = (() => { let o = b.map((i) => i.code.toLowerCase()).sort((i, r) => i.length > r.length ? -1 : 1).map((i) => { return { key: i, country: x[i], re: new RegExp("^" + i) } }); return function i (r) { let e; if (o.some((d) => { if (r.match(d.re)) return r = r.substr(d.key.length), e = d.country, !0 }), e) if (r) { let d = i(r); if (d) return d.unshift(e), d } else return [e] } })(), t = { tags: ["(X)", "(XY)", "(X, Y, ...)"], key: "countries", title: "Country list", description: "List of country for a ROM", re: /^\(([a-z14, ]+)\)$/i, cast (o) { let i = R(o[1]), r = n(i) || L(i); if (r) return r.map((e) => { return { ...e } }) } }; var j = { tags: ["[f]", "[f#]", "[f#C]", "[f#+C]", "[f#+#C]"], key: "fixed", title: "Fixed dump", description: "A fixed dump is a ROM that has been altered to run better on a flashcart or an emulator.", ...s("f") }; var w = { tags: ["(PAL)", "(NTSC)"], key: "format", title: "Format type", description: "Format type (PAL, NTSC)", re: /^\((PAL|NTSC)\)$/, cast (o) { return { [o[1].toLowerCase()]: !0 } } }; var X = { tag: "[!]", key: "good", title: "Verified good dump", description: "The ROM is an exact copy of the original game; it has not had any hacks or modifications.", re: /^\[!]$/ }; var m = { tags: ["(Hack)", "(XXX Hack)"], key: "hack", title: "Hack of another ROM", description: "This ROM is a hack of another ROM.", re: /^\(.*Hack\)$/i }; var G = { tags: ["[h]", "[h#]", "[h#C]", "[h#+C]", "[h#+#C]", "[hI]", "[h#I]", "[h#I+C]", "[h#I+#C]", "[hIR]", "[h#IR]", "[h#IR+C]", "[h#IR+#C]"], key: "hacked", title: "Hacked ROM", description: "The ROM has been user modified, with examples being changing the internal header or country codes, applying a release group intro, or editing the game's content.", re: /^\[h(\d*)(IR?)?(?:(?:(\+)(\d*))?C)?]$/, cast (o) { if (o[1] || o[2] || o[4]) { let i = { major: parseInt(o[1] || 0, 10), minor: parseInt(o[4] || 0, 10) || (o[3] ? 1 : 0) }; if (o[2] === "I") i.intro = !0; else if (o[2] === "IR") i.introRemoved = !0; return i } return !0 } }; var c = ["Camerica", "Aladdin", "Wisdom Tree", "AVE", "HES", "Color Dreams", "Tengen", "Panesian", "Joy Van", "Sachen", "Sachen-HES", "Sachen-Hacker", "Hacker"], K = { tags: ["(Camerica)", "(Aladdin)"], title: "Ignored tags", description: "Company name, special devices....", re: new RegExp(`^\\(${c.join("|")}\\)$`, "i") }; var N = { tag: "(M#)", key: "languageCount", title: "Language count", description: "Number of languages (selectable by a menu)", re: /^\(M(\d+)\)$/, cast (o) { return parseInt(o[1], 10) } }; var k = {}; C.forEach((o) => { k[o.code.toLowerCase()] = o, k[M(o.name)] = o }); var B = { tags: ["(X)", "(X Y)", "(X, Y, ...)"], key: "languages", title: "Language list", description: "List of language for a ROM", re: /^\(([a-z, -]+)\)$/i, cast (o) { let i = M(o[1]).split(/[,\s]+/).map((r) => r.trim()).map((r) => k[r] ? { ...k[r] } : null).filter((r) => Boolean(r)); if (i.length) return i } }; var E = { tags: ["[o]", "[o#]", "[o#C]", "[o#+C]", "[o#+#C]"], key: "overdumped", title: "Overdumped ROM", description: "The ROM contains more data than the original game. This extra data is useless and doesn't affect the game at all; it just makes the ROM bigger.", ...s("o") }; var J = { tag: "[!p]", key: "pending", title: "Pending dump", description: "This is the closest dump to the original game to date, but the proper ROM is still waiting to be dumped.", re: /^\[!p]$/ }; var U = { tags: ["[p]", "[p#]", "[p#C]", "[p#+C]", "[p#+#C]"], key: "pirated", title: "Pirated version", description: 'A dump of a pirated version of a game. These ROMs often have their copyright messages or company names removed or corrupted. Also, many ROMs contain "intro" screens with the name and symbols of the pirate group that have released them.', ...s("p") }; function l (o) { return o.toUpperCase().charCodeAt(0) - 64 } var q = { tags: ["(REVXX)", "(PRGXX)"], key: "revision", title: "Revision number", description: "0 is the earliest.", re: /^\((?:REV|PRG)\s*(?:(\d+)|([a-z]))\)$/i, cast (o) { return o[2] ? l(o[2]) : parseInt(o[1], 10) } }; var F = { tags: ["[t]", "[t#]", "[t#C]", "[t#+C]", "[t#+#C]"], key: "trained", title: "Trained version", description: "A trainer (special code which executes before starting the actual game) has been added to the ROM. It allows the player to access cheats from a menu or ingame.", ...s("t") }; var O = {}; C.forEach((o) => { O[V(o.code)] = o, O[V(o.name)] = o }); function V (o) { return o.toLowerCase().replace(/[^a-z]/g, "") } var Q = { tags: ["[T+XXX]", "[T-XXX]"], key: "translation", title: "Translation", description: "T+ : Most recent translation, T- : Obsolete translation", re: /^\[T([+-])([a-z]+)([0-9.]+(%?))?_?(.*)\]$/i, cast (o) { let i = o[1] === "+", r = O[V(o[2])], e = (o[4] ? o[3] : "") || "", d = (o[4] ? "" : o[3]) || "", H = o[5] || ""; return { ...r || { code: o[2], name: o[2] }, percent: e, version: d, author: H, latest: i } } }; function h (o) { return o.split(/[^a-z]+/i).map((i, r) => r ? i.charAt(0).toUpperCase() + i.slice(1).toLowerCase() : i.toLowerCase()).join("") } var Y = { tag: "(VX.X)", key: "version", title: "Version number", description: "1.0 is earliest", re: /^\(V(\d+)(?:\.(\d+)(?:\.(\d+))?)?\)$/, cast (o) { return { stable: { major: parseInt(o[1], 10), minor: o[2] ? parseInt(o[2], 10) : 0, patch: o[3] ? parseInt(o[3], 10) : 0 } } } }, Z = { tags: ["(Alpha)", "(Beta)", "(Pre-Release)", "(Prototype)", "(Proto)", "(Demo)", "(Sample)", "(old)"], key: "version", title: "Version type", description: "Type of version (Alpha, Beta...)", re: /^\((Alpha|Beta|Pre-Release|Prototype|Proto|Demo|Sample|old)(?:\s*(?:(\d+)(?:\.(\d+)(?:\.(\d+))?)?)|(.*))?\)$/i, cast (o) { let i = {}, r = h(o[1]); if (r === "proto") r = "prototype"; return i[r] = { major: o[2] ? parseInt(o[2], 10) : 1, minor: o[3] ? parseInt(o[3], 10) : 0, patch: o[4] ? parseInt(o[4], 10) : 0 }, i } }; var a = [X, m, J, A, j, E, U, S, T, F, G, q, Y, Z, Q, N, w, P, t, B, K]; function _ (o) { let i = {}; for (let r of a) { let e = o.match(r.re); if (e) { let d = r.cast ? r.cast(e) : !0; if (d !== void 0) { if (r.key) i[r.key] = d; return i } } } return } function D (o) { if (!o.codes.languages) { if (o.codes.translation) { let { code: i, name: r } = o.codes.translation; o.codes.languages = [{ code: i, name: r, translation: !0 }] } else if (o.codes.countries) { let i = o.codes.countries.map((r) => { let e = v(r.code); if (e) return { ...e, default: !0 } }).filter((r) => Boolean(r)); o.codes.languages = i.filter((r) => r === i.find((e) => e.code === r.code)) } } } function W (o) { if (!o.codes.version) o.codes.version = { stable: { major: 1, minor: 0, patch: 0 } } } var f = { bracket: /\[.*]/g, curly: /\(.*\)/g, prefix: /^\s*[0-9]+\s*-\s*/, spaces: /\s+(\.[a-z0-9]+)$/, extension: /\.[a-z0-9]+$/ }; function y (o) { return o.replace(f.bracket, "").replace(f.curly, "").replace(f.prefix, "").replace(f.spaces, "$1").trim() } function z (o) { return o.replace(f.extension, "") } var u = /((?:\[[^\]]+])|(?:\([^)]+\)))/g; function g (o) { let i = y(o), r = { file: o, cleaned: i, rom: z(i), codes: {} }; return (o.match(u) || []).forEach((d) => { let H = _(d); if (H) r.codes = { ...r.codes, ...H }; else { if (!r.unknown) r.unknown = []; r.unknown.push(d) } }), D(r), W(r), r } export { g as parse }
